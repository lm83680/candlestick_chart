// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1491123074;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__models__candlestick_from_service_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "candlestick_from_service_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::Candlestick::from_service_data(api_data),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__models__candlestick_list_from_service_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "candlestick_list_from_service_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<Vec<String>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::Candlestick::list_from_service_data(api_data),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__models__candlestick_mark_as_confirmed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "candlestick_mark_as_confirmed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::models::Candlestick>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::models::Candlestick::mark_as_confirmed(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__calculator__find_candlestick_indices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "find_candlestick_indices",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_list = <Vec<crate::api::models::Candlestick>>::sse_decode(&mut deserializer);
            let api_timestamps = <std::collections::HashSet<i64>>::sse_decode(&mut deserializer);
            let api_limit = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::calculator::find_candlestick_indices(
                            &api_list,
                            api_timestamps,
                            api_limit,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__calculator__find_candlesticks_price_range_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "find_candlesticks_price_range",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_candlesticks =
                <Vec<crate::api::models::Candlestick>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::calculator::find_candlesticks_price_range(&api_candlesticks),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__calculator__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::calculator::greet(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__models__price_calculator_get_candlestick_print_info_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "price_calculator_get_candlestick_print_info",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::models::PriceCalculator>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::models::PriceCalculator::get_candlestick_print_info(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__price_calculator_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "price_calculator_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_viewport_height = <f64>::sse_decode(&mut deserializer);
            let api_viewport_width = <f64>::sse_decode(&mut deserializer);
            let api_offset_x = <f64>::sse_decode(&mut deserializer);
            let api_scale_x = <f64>::sse_decode(&mut deserializer);
            let api_candle_width = <f64>::sse_decode(&mut deserializer);
            let api_candle_spacing = <f64>::sse_decode(&mut deserializer);
            let api_candlesticks =
                <Vec<crate::api::models::Candlestick>>::sse_decode(&mut deserializer);
            let api_top_safe_area_height = <f64>::sse_decode(&mut deserializer);
            let api_bottom_safe_area_height = <f64>::sse_decode(&mut deserializer);
            let api_bottom_time_label_height = <f64>::sse_decode(&mut deserializer);
            let api_grid_time_count = <i8>::sse_decode(&mut deserializer);
            let api_scale_y = <f64>::sse_decode(&mut deserializer);
            let api_crosshair_offset = <Option<(f64, f64)>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::models::PriceCalculator::new(
                    api_viewport_height,
                    api_viewport_width,
                    api_offset_x,
                    api_scale_x,
                    api_candle_width,
                    api_candle_spacing,
                    api_candlesticks,
                    api_top_safe_area_height,
                    api_bottom_safe_area_height,
                    api_bottom_time_label_height,
                    api_grid_time_count,
                    api_scale_y,
                    api_crosshair_offset,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__models__price_calculator_price_to_y_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "price_calculator_price_to_y",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_price = <f64>::sse_decode(&mut deserializer);
            let api_top_price = <f64>::sse_decode(&mut deserializer);
            let api_price_density = <f64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::models::PriceCalculator::price_to_y(
                            api_price,
                            api_top_price,
                            api_price_density,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__models__price_calculator_y_to_price_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "price_calculator_y_to_price",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_y = <f64>::sse_decode(&mut deserializer);
            let api_top_price = <f64>::sse_decode(&mut deserializer);
            let api_price_density = <f64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::models::PriceCalculator::y_to_price(
                            api_y,
                            api_top_price,
                            api_price_density,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for std::collections::HashMap<i64, usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(i64, usize)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for std::collections::HashSet<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<i64>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::models::Candlestick {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        let mut var_open = <f64>::sse_decode(deserializer);
        let mut var_high = <f64>::sse_decode(deserializer);
        let mut var_low = <f64>::sse_decode(deserializer);
        let mut var_close = <f64>::sse_decode(deserializer);
        let mut var_isConfirmed = <bool>::sse_decode(deserializer);
        return crate::api::models::Candlestick {
            timestamp: var_timestamp,
            open: var_open,
            high: var_high,
            low: var_low,
            close: var_close,
            is_confirmed: var_isConfirmed,
        };
    }
}

impl SseDecode for crate::api::models::CandlestickPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_candlestick = <crate::api::models::Candlestick>::sse_decode(deserializer);
        let mut var_openY = <f64>::sse_decode(deserializer);
        let mut var_closeY = <f64>::sse_decode(deserializer);
        let mut var_contentStartX = <f64>::sse_decode(deserializer);
        let mut var_contentEndX = <f64>::sse_decode(deserializer);
        let mut var_shadow = <(f64, f64, f64)>::sse_decode(deserializer);
        return crate::api::models::CandlestickPrintInfo {
            candlestick: var_candlestick,
            open_y: var_openY,
            close_y: var_closeY,
            content_start_x: var_contentStartX,
            content_end_x: var_contentEndX,
            shadow: var_shadow,
        };
    }
}

impl SseDecode for crate::api::models::CrosshairPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_candlestick =
            <Option<crate::api::models::Candlestick>>::sse_decode(deserializer);
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        let mut var_price = <f64>::sse_decode(deserializer);
        let mut var_x = <f64>::sse_decode(deserializer);
        let mut var_y = <f64>::sse_decode(deserializer);
        return crate::api::models::CrosshairPrintInfo {
            candlestick: var_candlestick,
            timestamp: var_timestamp,
            price: var_price,
            x: var_x,
            y: var_y,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::models::GridPricePrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_price = <f64>::sse_decode(deserializer);
        let mut var_y = <f64>::sse_decode(deserializer);
        return crate::api::models::GridPricePrintInfo {
            price: var_price,
            y: var_y,
        };
    }
}

impl SseDecode for crate::api::models::GridTimePrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <Option<i64>>::sse_decode(deserializer);
        let mut var_x = <f64>::sse_decode(deserializer);
        return crate::api::models::GridTimePrintInfo {
            timestamp: var_timestamp,
            x: var_x,
        };
    }
}

impl SseDecode for crate::api::models::HighPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_price = <f64>::sse_decode(deserializer);
        let mut var_x = <f64>::sse_decode(deserializer);
        let mut var_endX = <f64>::sse_decode(deserializer);
        let mut var_y = <f64>::sse_decode(deserializer);
        return crate::api::models::HighPrintInfo {
            price: var_price,
            x: var_x,
            end_x: var_endX,
            y: var_y,
        };
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i8().unwrap()
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::models::Candlestick> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::models::Candlestick>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::models::CandlestickPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::models::CandlestickPrintInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::models::GridPricePrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::models::GridPricePrintInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::models::GridTimePrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::models::GridTimePrintInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<String>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(i64, usize)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(i64, usize)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::models::LivePricePrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_price = <f64>::sse_decode(deserializer);
        let mut var_x = <f64>::sse_decode(deserializer);
        let mut var_endX = <f64>::sse_decode(deserializer);
        let mut var_y = <f64>::sse_decode(deserializer);
        let mut var_timestamp = <i64>::sse_decode(deserializer);
        let mut var_isVisible = <bool>::sse_decode(deserializer);
        return crate::api::models::LivePricePrintInfo {
            price: var_price,
            x: var_x,
            end_x: var_endX,
            y: var_y,
            timestamp: var_timestamp,
            is_visible: var_isVisible,
        };
    }
}

impl SseDecode for crate::api::models::LowPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_price = <f64>::sse_decode(deserializer);
        let mut var_x = <f64>::sse_decode(deserializer);
        let mut var_endX = <f64>::sse_decode(deserializer);
        let mut var_y = <f64>::sse_decode(deserializer);
        return crate::api::models::LowPrintInfo {
            price: var_price,
            x: var_x,
            end_x: var_endX,
            y: var_y,
        };
    }
}

impl SseDecode for Option<crate::api::models::Candlestick> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::models::Candlestick>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::models::CrosshairPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::models::CrosshairPrintInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::models::HighPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::models::HighPrintInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::models::LivePricePrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::models::LivePricePrintInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::models::LowPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::models::LowPrintInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<(f64, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(f64, f64)>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::models::PriceCalculator {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_viewportHeight = <f64>::sse_decode(deserializer);
        let mut var_viewportWidth = <f64>::sse_decode(deserializer);
        let mut var_offsetX = <f64>::sse_decode(deserializer);
        let mut var_scaleX = <f64>::sse_decode(deserializer);
        let mut var_candleWidth = <f64>::sse_decode(deserializer);
        let mut var_candleSpacing = <f64>::sse_decode(deserializer);
        let mut var_candlesticks = <Vec<crate::api::models::Candlestick>>::sse_decode(deserializer);
        let mut var_topSafeAreaHeight = <f64>::sse_decode(deserializer);
        let mut var_bottomSafeAreaHeight = <f64>::sse_decode(deserializer);
        let mut var_bottomTimeLabelHeight = <f64>::sse_decode(deserializer);
        let mut var_gridTimeCount = <i8>::sse_decode(deserializer);
        let mut var_scaleY = <f64>::sse_decode(deserializer);
        let mut var_crosshairOffset = <Option<(f64, f64)>>::sse_decode(deserializer);
        return crate::api::models::PriceCalculator {
            viewport_height: var_viewportHeight,
            viewport_width: var_viewportWidth,
            offset_x: var_offsetX,
            scale_x: var_scaleX,
            candle_width: var_candleWidth,
            candle_spacing: var_candleSpacing,
            candlesticks: var_candlesticks,
            top_safe_area_height: var_topSafeAreaHeight,
            bottom_safe_area_height: var_bottomSafeAreaHeight,
            bottom_time_label_height: var_bottomTimeLabelHeight,
            grid_time_count: var_gridTimeCount,
            scale_y: var_scaleY,
            crosshair_offset: var_crosshairOffset,
        };
    }
}

impl SseDecode for (f64, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <f64>::sse_decode(deserializer);
        let mut var_field1 = <f64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (f64, f64, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <f64>::sse_decode(deserializer);
        let mut var_field1 = <f64>::sse_decode(deserializer);
        let mut var_field2 = <f64>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for (i64, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <i64>::sse_decode(deserializer);
        let mut var_field1 = <usize>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        Vec<crate::api::models::CandlestickPrintInfo>,
        Vec<crate::api::models::GridTimePrintInfo>,
        Vec<crate::api::models::GridPricePrintInfo>,
        Option<crate::api::models::LivePricePrintInfo>,
        Option<crate::api::models::HighPrintInfo>,
        Option<crate::api::models::LowPrintInfo>,
        Option<crate::api::models::CrosshairPrintInfo>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <Vec<crate::api::models::CandlestickPrintInfo>>::sse_decode(deserializer);
        let mut var_field1 = <Vec<crate::api::models::GridTimePrintInfo>>::sse_decode(deserializer);
        let mut var_field2 =
            <Vec<crate::api::models::GridPricePrintInfo>>::sse_decode(deserializer);
        let mut var_field3 =
            <Option<crate::api::models::LivePricePrintInfo>>::sse_decode(deserializer);
        let mut var_field4 = <Option<crate::api::models::HighPrintInfo>>::sse_decode(deserializer);
        let mut var_field5 = <Option<crate::api::models::LowPrintInfo>>::sse_decode(deserializer);
        let mut var_field6 =
            <Option<crate::api::models::CrosshairPrintInfo>>::sse_decode(deserializer);
        return (
            var_field0, var_field1, var_field2, var_field3, var_field4, var_field5, var_field6,
        );
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__models__candlestick_from_service_data_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        2 => wire__crate__api__models__candlestick_list_from_service_data_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        3 => wire__crate__api__models__candlestick_mark_as_confirmed_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        4 => wire__crate__api__calculator__find_candlestick_indices_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__api__calculator__find_candlesticks_price_range_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        7 => wire__crate__api__init_app_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__models__price_calculator_price_to_y_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        11 => wire__crate__api__models__price_calculator_y_to_price_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        6 => wire__crate__api__calculator__greet_impl(ptr, rust_vec_len, data_len),
        8 => wire__crate__api__models__price_calculator_get_candlestick_print_info_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        9 => wire__crate__api__models__price_calculator_new_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::Candlestick {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.open.into_into_dart().into_dart(),
            self.high.into_into_dart().into_dart(),
            self.low.into_into_dart().into_dart(),
            self.close.into_into_dart().into_dart(),
            self.is_confirmed.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::Candlestick
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::Candlestick>
    for crate::api::models::Candlestick
{
    fn into_into_dart(self) -> crate::api::models::Candlestick {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::CandlestickPrintInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.candlestick.into_into_dart().into_dart(),
            self.open_y.into_into_dart().into_dart(),
            self.close_y.into_into_dart().into_dart(),
            self.content_start_x.into_into_dart().into_dart(),
            self.content_end_x.into_into_dart().into_dart(),
            self.shadow.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::CandlestickPrintInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::CandlestickPrintInfo>
    for crate::api::models::CandlestickPrintInfo
{
    fn into_into_dart(self) -> crate::api::models::CandlestickPrintInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::CrosshairPrintInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.candlestick.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.price.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::CrosshairPrintInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::CrosshairPrintInfo>
    for crate::api::models::CrosshairPrintInfo
{
    fn into_into_dart(self) -> crate::api::models::CrosshairPrintInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::GridPricePrintInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.price.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::GridPricePrintInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::GridPricePrintInfo>
    for crate::api::models::GridPricePrintInfo
{
    fn into_into_dart(self) -> crate::api::models::GridPricePrintInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::GridTimePrintInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::GridTimePrintInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::GridTimePrintInfo>
    for crate::api::models::GridTimePrintInfo
{
    fn into_into_dart(self) -> crate::api::models::GridTimePrintInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::HighPrintInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.price.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
            self.end_x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::HighPrintInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::HighPrintInfo>
    for crate::api::models::HighPrintInfo
{
    fn into_into_dart(self) -> crate::api::models::HighPrintInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::LivePricePrintInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.price.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
            self.end_x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.is_visible.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::LivePricePrintInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::LivePricePrintInfo>
    for crate::api::models::LivePricePrintInfo
{
    fn into_into_dart(self) -> crate::api::models::LivePricePrintInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::LowPrintInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.price.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
            self.end_x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::LowPrintInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::LowPrintInfo>
    for crate::api::models::LowPrintInfo
{
    fn into_into_dart(self) -> crate::api::models::LowPrintInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::models::PriceCalculator {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.viewport_height.into_into_dart().into_dart(),
            self.viewport_width.into_into_dart().into_dart(),
            self.offset_x.into_into_dart().into_dart(),
            self.scale_x.into_into_dart().into_dart(),
            self.candle_width.into_into_dart().into_dart(),
            self.candle_spacing.into_into_dart().into_dart(),
            self.candlesticks.into_into_dart().into_dart(),
            self.top_safe_area_height.into_into_dart().into_dart(),
            self.bottom_safe_area_height.into_into_dart().into_dart(),
            self.bottom_time_label_height.into_into_dart().into_dart(),
            self.grid_time_count.into_into_dart().into_dart(),
            self.scale_y.into_into_dart().into_dart(),
            self.crosshair_offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::models::PriceCalculator
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::models::PriceCalculator>
    for crate::api::models::PriceCalculator
{
    fn into_into_dart(self) -> crate::api::models::PriceCalculator {
        self
    }
}

impl SseEncode for std::collections::HashMap<i64, usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(i64, usize)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for std::collections::HashSet<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<i64>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::models::Candlestick {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.timestamp, serializer);
        <f64>::sse_encode(self.open, serializer);
        <f64>::sse_encode(self.high, serializer);
        <f64>::sse_encode(self.low, serializer);
        <f64>::sse_encode(self.close, serializer);
        <bool>::sse_encode(self.is_confirmed, serializer);
    }
}

impl SseEncode for crate::api::models::CandlestickPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::models::Candlestick>::sse_encode(self.candlestick, serializer);
        <f64>::sse_encode(self.open_y, serializer);
        <f64>::sse_encode(self.close_y, serializer);
        <f64>::sse_encode(self.content_start_x, serializer);
        <f64>::sse_encode(self.content_end_x, serializer);
        <(f64, f64, f64)>::sse_encode(self.shadow, serializer);
    }
}

impl SseEncode for crate::api::models::CrosshairPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::models::Candlestick>>::sse_encode(self.candlestick, serializer);
        <i64>::sse_encode(self.timestamp, serializer);
        <f64>::sse_encode(self.price, serializer);
        <f64>::sse_encode(self.x, serializer);
        <f64>::sse_encode(self.y, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::models::GridPricePrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.price, serializer);
        <f64>::sse_encode(self.y, serializer);
    }
}

impl SseEncode for crate::api::models::GridTimePrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i64>>::sse_encode(self.timestamp, serializer);
        <f64>::sse_encode(self.x, serializer);
    }
}

impl SseEncode for crate::api::models::HighPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.price, serializer);
        <f64>::sse_encode(self.x, serializer);
        <f64>::sse_encode(self.end_x, serializer);
        <f64>::sse_encode(self.y, serializer);
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i8(self).unwrap();
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::models::Candlestick> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::models::Candlestick>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::models::CandlestickPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::models::CandlestickPrintInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::models::GridPricePrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::models::GridPricePrintInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::models::GridTimePrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::models::GridTimePrintInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<String>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(i64, usize)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(i64, usize)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::models::LivePricePrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.price, serializer);
        <f64>::sse_encode(self.x, serializer);
        <f64>::sse_encode(self.end_x, serializer);
        <f64>::sse_encode(self.y, serializer);
        <i64>::sse_encode(self.timestamp, serializer);
        <bool>::sse_encode(self.is_visible, serializer);
    }
}

impl SseEncode for crate::api::models::LowPrintInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.price, serializer);
        <f64>::sse_encode(self.x, serializer);
        <f64>::sse_encode(self.end_x, serializer);
        <f64>::sse_encode(self.y, serializer);
    }
}

impl SseEncode for Option<crate::api::models::Candlestick> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::models::Candlestick>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::models::CrosshairPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::models::CrosshairPrintInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::models::HighPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::models::HighPrintInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::models::LivePricePrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::models::LivePricePrintInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::models::LowPrintInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::models::LowPrintInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<(f64, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(f64, f64)>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::models::PriceCalculator {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.viewport_height, serializer);
        <f64>::sse_encode(self.viewport_width, serializer);
        <f64>::sse_encode(self.offset_x, serializer);
        <f64>::sse_encode(self.scale_x, serializer);
        <f64>::sse_encode(self.candle_width, serializer);
        <f64>::sse_encode(self.candle_spacing, serializer);
        <Vec<crate::api::models::Candlestick>>::sse_encode(self.candlesticks, serializer);
        <f64>::sse_encode(self.top_safe_area_height, serializer);
        <f64>::sse_encode(self.bottom_safe_area_height, serializer);
        <f64>::sse_encode(self.bottom_time_label_height, serializer);
        <i8>::sse_encode(self.grid_time_count, serializer);
        <f64>::sse_encode(self.scale_y, serializer);
        <Option<(f64, f64)>>::sse_encode(self.crosshair_offset, serializer);
    }
}

impl SseEncode for (f64, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.0, serializer);
        <f64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (f64, f64, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.0, serializer);
        <f64>::sse_encode(self.1, serializer);
        <f64>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for (i64, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.0, serializer);
        <usize>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        Vec<crate::api::models::CandlestickPrintInfo>,
        Vec<crate::api::models::GridTimePrintInfo>,
        Vec<crate::api::models::GridPricePrintInfo>,
        Option<crate::api::models::LivePricePrintInfo>,
        Option<crate::api::models::HighPrintInfo>,
        Option<crate::api::models::LowPrintInfo>,
        Option<crate::api::models::CrosshairPrintInfo>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::models::CandlestickPrintInfo>>::sse_encode(self.0, serializer);
        <Vec<crate::api::models::GridTimePrintInfo>>::sse_encode(self.1, serializer);
        <Vec<crate::api::models::GridPricePrintInfo>>::sse_encode(self.2, serializer);
        <Option<crate::api::models::LivePricePrintInfo>>::sse_encode(self.3, serializer);
        <Option<crate::api::models::HighPrintInfo>>::sse_encode(self.4, serializer);
        <Option<crate::api::models::LowPrintInfo>>::sse_encode(self.5, serializer);
        <Option<crate::api::models::CrosshairPrintInfo>>::sse_encode(self.6, serializer);
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;
